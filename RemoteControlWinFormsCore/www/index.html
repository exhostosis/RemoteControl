<html>

<head>
    <title>
        Громкость
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimum-scale=1" charset="utf8" />

    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">

    <script>
        class Point {
            constructor(x, y, id = 0) {
                this.x = Math.round(x);
                this.y = Math.round(y);
                this.id = id;
                this.start = new Date();
            }

            checkRange(that) {
                return Math.abs(this.x - that.x) <= CLICKRANGE &&
                    Math.abs(this.y - that.y) <= CLICKRANGE;
            }

            checkTime(that) {
                return that.start - this.start <= CLICKINTERVAL;
            }
        }

        class GestureDetector {
            constructor(element) {
                element.addEventListener('touchmove', this.processTouchMove.bind(this));
                element.addEventListener('touchstart', this.startTouch.bind(this));
                element.addEventListener('touchend', this.endTouch.bind(this));
                element.addEventListener('touchcancel', this.endTouch.bind(this));

                this.dragStartTimer = undefined;
                this.lastMovePosition = undefined;
                this.touchesCache = [];
                this.MODIFIER = 3;
                this.dragging = false;
            }

            tryStopDrag() {
                if (this.dragStartTimer !== undefined) {
                    clearTimeout(this.dragStartTimer);
                    this.dragStartTimer = undefined;
                }
                if (this.dragging) {
                    this.dragging = false;
                    this.oneFingerDrag(false);
                }
            }

            processTouchMove(e) {
                if (e.targetTouches.length <= 2) {
                    if (e.targetTouches.length === 1 && this.dragStartTimer !== undefined) {
                        if (!(this.touchesCache[0].checkRange(new Point(e.targetTouches[0].clientX, e.targetTouches[0].clientY)))) {
                            this.tryStopDrag();
                        }
                    }

                    const pos = new Point(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
                    if (!this.lastMovePosition) {
                        this.lastMovePosition = new Point(this.touchesCache[0].x, this.touchesCache[0].y);
                    }

                    const diff = new Point(pos.x - this.lastMovePosition.x, pos.y - this.lastMovePosition.y);

                    this.lastMovePosition = pos;

                    if (e.targetTouches.length === 1) {
                        this.oneFingerMove(JSON.stringify({
                            x: diff.x * this.MODIFIER,
                            y: diff.y * this.MODIFIER
                        }));
                    }
                    if (e.targetTouches.length === 2 && Math.abs(diff.y) > 10) {
                        this.twoFingersMove(diff.y > 0 ? 'up' : 'down');
                    }
                }
            }

            getTouchIndex(identifier) {
                for (let i = 0; i < this.touchesCache.length; i += 1) {
                    if (this.touchesCache[i].id === identifier) {
                        return i;
                    }
                }

                return -1;
            }

            addTouch(t) {
                if (this.getTouchIndex(t.identifier) === -1) {
                    this.touchesCache.push(new Point(t.clientX, t.clientY, t.identifier));
                }
            }

            startTouch(e) {
                for (let i = 0; i < e.changedTouches.length; i += 1) {
                    this.addTouch(e.changedTouches[i]);
                }

                if (this.touchesCache.length === 1) {
                    this.dragStartTimer = setTimeout(() => {
                        this.oneFingerDrag(true);
                        this.dragStartTimer = undefined;
                        this.dragging = true;
                    }, 1000);
                } else {
                    this.tryStopDrag();
                }
            }

            endTouch(e) {
                for (let i = 0; i < e.changedTouches.length; i += 1) {
                    const id = this.getTouchIndex(e.changedTouches[i].identifier);

                    if (id !== -1) {
                        const temp = new Point(e.changedTouches[i].clientX, e.changedTouches[i].clientY);

                        if (!(this.touchesCache[id].checkTime(temp)) || !(this.touchesCache[id].checkRange(temp))) {
                            this.touchesCache.splice(id, 1);
                        }
                    }
                }

                if (e.targetTouches.length === 0) {
                    const {
                        length
                    } = this.touchesCache;
                    if (length >= 1 && length <= 3) {
                        switch (length) {
                            case 1:
                                this.oneFingerClick();
                                break;
                            case 2:
                                this.twoFingersClick();
                                break;
                            case 3:
                                this.threeFingersClick();
                                break;
                            default:
                                break;
                        }
                    }

                    this.touchesCache = [];
                    this.lastMovePosition = undefined;
                    this.tryStopDrag();
                }
            }
        }

        function sendRequest(method, param) {
            return fetch(`/api/${method}/${param}`);
        }

        //volume slider

        let SLIDERSCALE = 0;
        const HANDLECLASS = 'volume-handle';
        const COLOREDCLASS = 'volume-colored';
        const BARID = 'volume-bar';
        const NUMERICID = 'volume-numeric';

        let volumeBar;
        let volumeBarColored;
        let volumeBarHandle;
        let sliderElement;

        let volumeBarNumericElement;

        let volumeNumericValue = 0;

        let numericEnabled = false;

        let drag = false;

        const changeEvent = new Event('volumechanged');

        function setVolumeBar(value) {
            const correction = volumeBarHandle.offsetWidth / 2;

            let pixelValue = value - volumeBar.offsetLeft;
            pixelValue = pixelValue <= volumeBar.offsetWidth - correction ? pixelValue : volumeBar.offsetWidth - correction;
            pixelValue = pixelValue >= correction ? pixelValue : correction;

            volumeBarHandle.style.marginLeft = pixelValue - correction;
            volumeBarColored.style.width = pixelValue;

            return pixelValue;
        }

        function setVolumeBarNumeric(value) {
            volumeBarNumericElement.innerText = value;
        }

        function toPixels(value) {
            return ((volumeBar.offsetWidth - volumeBarHandle.offsetWidth) / SLIDERSCALE) * value + (volumeBarHandle.offsetWidth / 2) + volumeBar.offsetLeft;
        }

        function toNumeric(value) {
            return Math.round(((value - (volumeBarHandle.offsetWidth / 2)) * SLIDERSCALE) / (volumeBar.offsetWidth - volumeBarHandle.offsetWidth));
        }

        function checkSendRequest(value) {
            const newNumeric = toNumeric(setVolumeBar(value));

            if (newNumeric !== volumeNumericValue) {
                volumeNumericValue = newNumeric;

                changeEvent.value = newNumeric;
                sliderElement.dispatchEvent(changeEvent);
                if (numericEnabled) {
                    setVolumeBarNumeric(newNumeric);
                }
            }
        }

        function wheel(e) {
            checkSendRequest(toPixels(e > 0 ? volumeNumericValue + 2 : volumeNumericValue - 2));
        }

        function init(initialValue) {
            volumeNumericValue = Number(initialValue);

            if (!Number.isNaN(volumeNumericValue)) {
                setVolumeBar(toPixels(volumeNumericValue));

                if (numericEnabled) {
                    setVolumeBarNumeric(volumeNumericValue);
                }
            }
        }

        function createVolumeBar(slider, scale, initValue = 0, numeric = false) {
            SLIDERSCALE = scale;
            numericEnabled = numeric;

            sliderElement = slider;

            let html = `<div id='${BARID}'></div>`;
            html = numericEnabled ? `<div id='${NUMERICID}'>0</div>\n${html}` : html;

            sliderElement.innerHTML = html;

            volumeBar = sliderElement.querySelector(`#${BARID}`);

            if (numeric) {
                volumeBarNumericElement = sliderElement.querySelector(`#${NUMERICID}`);
            }

            volumeBar.innerHTML = `
                <div class='${COLOREDCLASS}'></div>
                <div class='${HANDLECLASS}'></div>
            `;

            volumeBarHandle = volumeBar.querySelector(`.${HANDLECLASS}`);
            volumeBarColored = volumeBar.querySelector(`.${COLOREDCLASS}`);

            volumeBarHandle.addEventListener('touchmove', e => {
                checkSendRequest(e.targetTouches[0].clientX);
            });
            volumeBar.addEventListener('click', e => {
                checkSendRequest(e.clientX);
            });
            volumeBar.addEventListener('wheel', e => {
                wheel(e.wheelDeltaY);
            });

            volumeBarHandle.addEventListener('mousedown', () => {
                drag = true;
            });
            volumeBarHandle.addEventListener('mouseup', () => {
                drag = false;
            });
            volumeBarHandle.addEventListener('mousemove', e => {
                if (drag) checkSendRequest(e.clientX);
            });

            init(initValue);
        }

        //touch

        const CLICKINTERVAL = 200;
        const CLICKRANGE = 10;

        let touchElement;
        let touchPointers;

        const touchEvent = new Event('touchpanelclick');
        const moveEvent = new Event('touchpanelmove');
        const scrollEvent = new Event('touchpanelscroll');
        const dragEvent = new Event('touchpaneldrag');

        function showPointer(p) {
            const elem = p;
            elem.style.display = 'block';
        }

        function movePointer(p, x, y) {
            const elem = p;
            elem.style.left = x - p.offsetWidth / 2;
            elem.style.top = y - p.offsetHeight / 2;
        }

        function hidePointer(p) {
            const elem = p;
            elem.style.display = 'none';
        }

        function processTouchMove(e) {
            Array.from(e.changedTouches).forEach(element => {
                movePointer(touchPointers[element.identifier], element.clientX, element.clientY);
            });
        }

        function startTouch(e) {
            Array.from(e.changedTouches).forEach(element => {
                showPointer(touchPointers[element.identifier]);
                movePointer(touchPointers[element.identifier], element.clientX, element.clientY);
            });
        }

        function endTouch(e) {
            Array.from(e.changedTouches).forEach(element => {
                hidePointer(touchPointers[element.identifier]);
            });
        }

        function createTouch(element) {
            touchElement = element;

            touchPointers = [
                new DOMParser().parseFromString('<div class="touch-pointer"></div>', 'text/html').body.firstChild,
                new DOMParser().parseFromString('<div class="touch-pointer"></div>', 'text/html').body.firstChild,
                new DOMParser().parseFromString('<div class="touch-pointer"></div>', 'text/html').body.firstChild,
                new DOMParser().parseFromString('<div class="touch-pointer"></div>', 'text/html').body.firstChild,
                new DOMParser().parseFromString('<div class="touch-pointer"></div>', 'text/html').body.firstChild,
            ];

            touchPointers.forEach(x => {
                touchElement.append(x);
            });

            touchElement.addEventListener('touchmove', processTouchMove, {
                passive: false
            });
            touchElement.addEventListener('touchstart', startTouch, {
                passive: false
            });
            touchElement.addEventListener('touchend', endTouch);
            touchElement.addEventListener('touchcancel', endTouch);

            const gt = new GestureDetector(touchElement);

            gt.oneFingerClick = () => {
                touchEvent.touches = 'left';
                touchElement.dispatchEvent(touchEvent);
            };
            gt.twoFingersClick = () => {
                touchEvent.touches = 'right';
                touchElement.dispatchEvent(touchEvent);
            };
            gt.threeFingersClick = () => {
                touchEvent.touches = 'middle';
                touchElement.dispatchEvent(touchEvent);
            };
            gt.oneFingerMove = coords => {
                moveEvent.position = coords;
                touchElement.dispatchEvent(moveEvent);
            };
            gt.twoFingersMove = direction => {
                scrollEvent.direction = direction;
                touchElement.dispatchEvent(scrollEvent);
            };
            gt.oneFingerDrag = s => {
                dragEvent.start = s;
                touchElement.dispatchEvent(dragEvent);
            };
        }

        let prev = '';
        let prevBorder = '';

        function touchHide() {
            prev = touchElement.style.display;
            prevBorder = touchElement.style.border;
            touchElement.style.border = 'none';
            touchElement.style.display = 'none';
        }

        function touchShow() {
            touchElement.style.display = prev;
            setTimeout(() => {
                touchElement.style.border = prevBorder;
            }, 200);
        }

        //keys

        const buttonschangeCLICKINTERVAL = 1000;

        let keyRepeadIntervalId;
        let keyRepeatTimerId;

        const clickEvent = new Event('keyclick');

        let buttonsGlobal;

        function start(value) {
            clickEvent.value = value;

            keyRepeatTimerId = setTimeout(() => {
                keyRepeadIntervalId = setInterval(() => {
                    buttonsGlobal.dispatchEvent(clickEvent);
                }, 100);
            }, 1000);
        }

        function end() {
            clearInterval(keyRepeatTimerId);
            clearTimeout(keyRepeadIntervalId);
        }

        function toggleDisplay(buttonsArray) {
            buttonsArray.forEach(x => {
                const elem = x;
                elem.style.display = elem.style.display === 'none' ? 'block' : 'none';
            });
        }

        function createKeys(buttons) {
            buttonsGlobal = buttons;

            const buttonBack = document.createElement('button');
            buttonBack.innerHTML = '&#60;&#60;';

            const buttonPause = document.createElement('button');
            buttonPause.innerHTML = '&#10074;&#10074;';

            const buttonForth = document.createElement('button');
            buttonForth.innerHTML = '&#62;&#62;';

            const buttonMediaForth = document.createElement('button');
            buttonMediaForth.innerHTML = '&#45;&#62;';
            buttonMediaForth.style.display = 'none';

            const buttonMediaBack = document.createElement('button');
            buttonMediaBack.innerHTML = '&#60;&#45;';
            buttonMediaBack.style.display = 'none';

            const fillers = [document.createElement('span'), document.createElement('span')];
            fillers.forEach(e => {
                e.style.float = 'left';
                e.style.height = '1px';
                e.style.width = '0.5%';
            });

            buttons.append(buttonMediaBack, buttonBack, fillers[0], buttonPause, fillers[1], buttonForth, buttonMediaForth);

            buttonBack.addEventListener('touchstart', () => start('back'));
            buttonBack.addEventListener('touchend', end);
            buttonBack.addEventListener('click', () => {
                clickEvent.value = 'back';
                buttons.dispatchEvent(clickEvent);
            });
            buttonBack.addEventListener('touchcancel', end);

            buttonForth.addEventListener('touchstart', () => start('forth'));
            buttonForth.addEventListener('touchend', end);
            buttonForth.addEventListener('click', () => {
                clickEvent.value = 'forth';
                buttons.dispatchEvent(clickEvent);
            });
            buttonForth.addEventListener('touchcancel', end);

            buttonMediaBack.addEventListener('click', () => {
                clickEvent.value = 'mediaback';
                buttons.dispatchEvent(clickEvent);
            });
            buttonMediaForth.addEventListener('click', () => {
                clickEvent.value = 'mediaforth';
                buttons.dispatchEvent(clickEvent);
            });

            const buttonsArray = [buttonBack, buttonForth, buttonMediaBack, buttonMediaForth];

            let timeout;

            buttonPause.addEventListener('click', () => {
                clickEvent.value = 'pause';
                buttons.dispatchEvent(clickEvent);
            });

            buttonPause.addEventListener('touchstart', () => {
                timeout = setTimeout(() => toggleDisplay(buttonsArray), buttonschangeCLICKINTERVAL);
            });
            buttonPause.addEventListener('touchend', () => {
                clearTimeout(timeout);
            });
        }

        //text

        const textEvent = new Event('textinput');

        let textElement;

        function processText(e) {
            if (e.key === 'Enter') {
                if (e.target.value) {
                    textEvent.text = encodeURIComponent(e.target.value);
                    textElement.dispatchEvent(textEvent);
                }
                e.target.blur();
            }
        }

        function createTextInput(element) {
            textElement = element;

            element.addEventListener('keyup', processText);
        }

        //init

        const Modes = {
            Audio: 'audio',
            Mouse: 'mouse',
            Keyboard: 'keyboard',
            Text: 'text',
        };

        function initElements(volume) {

            console.log(volume);

            const slider = document.getElementById('slider');

            if (slider) {
                createVolumeBar(slider, 100, volume, true);
                slider.addEventListener('volumechanged', e => sendRequest(Modes.Audio, e.value));
            }

            const touch = document.getElementById('touch');

            if (touch) {
                createTouch(touch);
                touch.addEventListener('touchpanelclick', e => sendRequest(Modes.Mouse, e.touches));
                touch.addEventListener('touchpanelmove', e => {
                    if (e.position) sendRequest(Modes.Mouse, e.position);
                });
                touch.addEventListener('touchpanelscroll', e => {
                    sendRequest(Modes.Mouse, e.direction);
                });
                touch.addEventListener('touchpaneldrag', e => {
                    sendRequest(Modes.Mouse, e.start ? 'dragstart' : 'dragstop');
                });
            }

            const buttons = document.getElementById('buttons');

            if (buttons) {
                createKeys(buttons);
                buttons.addEventListener('keyclick', e => sendRequest(Modes.Keyboard, e.value));
            }

            const textInput = document.getElementById('text-input');

            if (textInput) {
                createTextInput(textInput);
                textInput.addEventListener('textinput', e => sendRequest(Modes.Text, e.text));
                textInput.addEventListener('focus', () => touchHide());
                textInput.addEventListener('blur', e => {
                    e.target.value = '';
                    touchShow();
                });
            }

            const loader = document.getElementById('loader');

            if (loader) {
                document.getElementById('loader').style.display = 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', async() => {
            initElements(await (await sendRequest(Modes.Audio, 'init')).text());
        });
    </script>

    <style>
        body {
            background: #2a2a2a;
            overscroll-behavior: none;
        }
        
        #outer-container {
            display: block;
            height: 100%;
        }
        
        #volume-bar {
            display: block;
            margin: 0 auto;
            height: 60px;
            width: 100%;
            background: #555;
            border-radius: 15px;
            margin-bottom: 10px;
        }
        
        #text-input {
            display: none;
            height: 50px;
            width: 100%;
            background: #555;
            border-radius: 15px;
            border: 0;
            color: white;
            padding-left: 5px;
            font-size: 18pt;
        }
        
        #volume-bar .volume-colored {
            height: 60px;
            position: absolute;
            background: #2ecc71;
            border: none;
            border-radius: 15px;
            outline: none;
        }
        
        #volume-bar .volume-handle {
            width: 70px;
            height: 70px;
            border-radius: 20px;
            background: #FFF;
            position: absolute;
            margin-top: -5px;
            cursor: pointer;
            outline: none;
        }
        
        button {
            cursor: pointer;
            font-weight: bold;
            text-align: center;
            color: #fff;
            border-radius: 30px;
            background-color: #538fbe;
            border: 1px solid #2d6898;
            text-shadow: 0px 0px 6px rgba(0, 0, 0, .8);
            display: block;
            width: 33%;
            float: left;
            padding-top: 8px;
            text-decoration: none;
            font-size: 50pt;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            line-height: 0px;
            height: 115px;
            margin-bottom: 10px;
        }
        
        button:active {
            background-color: #73afde;
            box-shadow: 0 3px 0 #2b638f;
            transform: translateY(5px);
        }
        
        #volume-numeric {
            text-align: center;
            font-size: 70pt;
            color: white;
        }
        
        #touch {
            display: none;
            width: 100%;
            border: 1px solid rgba(135, 206, 250, 0.541);
            border-radius: 15px;
        }
        
        .touch-pointer {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: radial-gradient(25px, lightskyblue, transparent);
            display: none;
        }
        
        #loader {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1000;
            background-color: #2a2a2a;
            top: 0;
            left: 0;
        }
        
        .lds-spinner {
            display: inline-block;
            position: absolute;
            left: calc(50% - 40px);
            top: calc(50% - 40px);
            width: 80px;
            height: 80px;
        }
        
        .lds-spinner div {
            transform-origin: 40px 40px;
            animation: lds-spinner 1.2s linear infinite;
        }
        
        .lds-spinner div:after {
            content: " ";
            display: block;
            position: absolute;
            top: 3px;
            left: 37px;
            width: 6px;
            height: 18px;
            border-radius: 20%;
            background: lightskyblue;
        }
        
        .lds-spinner div:nth-child(1) {
            transform: rotate(0deg);
            animation-delay: -1.1s;
        }
        
        .lds-spinner div:nth-child(2) {
            transform: rotate(30deg);
            animation-delay: -1s;
        }
        
        .lds-spinner div:nth-child(3) {
            transform: rotate(60deg);
            animation-delay: -0.9s;
        }
        
        .lds-spinner div:nth-child(4) {
            transform: rotate(90deg);
            animation-delay: -0.8s;
        }
        
        .lds-spinner div:nth-child(5) {
            transform: rotate(120deg);
            animation-delay: -0.7s;
        }
        
        .lds-spinner div:nth-child(6) {
            transform: rotate(150deg);
            animation-delay: -0.6s;
        }
        
        .lds-spinner div:nth-child(7) {
            transform: rotate(180deg);
            animation-delay: -0.5s;
        }
        
        .lds-spinner div:nth-child(8) {
            transform: rotate(210deg);
            animation-delay: -0.4s;
        }
        
        .lds-spinner div:nth-child(9) {
            transform: rotate(240deg);
            animation-delay: -0.3s;
        }
        
        .lds-spinner div:nth-child(10) {
            transform: rotate(270deg);
            animation-delay: -0.2s;
        }
        
        .lds-spinner div:nth-child(11) {
            transform: rotate(300deg);
            animation-delay: -0.1s;
        }
        
        .lds-spinner div:nth-child(12) {
            transform: rotate(330deg);
            animation-delay: 0s;
        }
        
        @keyframes lds-spinner {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        @media only screen and (min-width: 300px) {
            #text-input {
                display: block;
            }
            #touch {
                display: block;
            }
            #outer-container {
                display: block;
            }
            #inner-container {
                width: 100%;
                height: 375px;
            }
            #touch {
                width: 100%;
                height: calc(100% - 375px);
            }
        }
        
        @media only screen and (min-width: 600px) {
            #outer-container {
                display: flex;
            }
            #inner-container {
                width: 50%;
                height: 100%;
            }
            #touch {
                width: 50%;
                height: 100%;
            }
        }
    </style>

</head>

<body>
    <div id="outer-container">
        <div id="inner-container">
            <div id="slider"></div>
            <div id="buttons"></div>
            <input type="text" autocomplete="false" id="text-input" />
        </div>
        <div id="touch"></div>
    </div>
    <div id="loader">
        <div class="lds-spinner">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</body>

</html>