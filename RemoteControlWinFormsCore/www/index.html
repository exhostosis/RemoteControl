<html>

<head>
    <title>
        Громкость
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimum-scale=1" charset="utf8" />

    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">

    <script>
        function sendRequest(method, param) {
            return fetch(`/api/v1/${method}/${param}`);
        }

        class Point {
            constructor(x, y, id = 0) {
                this.x = Math.round(x);
                this.y = Math.round(y);
                this.id = id;
                this.start = new Date();
            }

            checkRange(that) {
                return Math.abs(this.x - that.x) <= CLICKRANGE &&
                    Math.abs(this.y - that.y) <= CLICKRANGE;
            }

            checkTime(that) {
                return that.start - this.start <= CLICKINTERVAL;
            }
        }

        class GestureDetector {
            constructor(element, touches) {
                element.addEventListener('touchmove', this.processTouchMove.bind(this));
                element.addEventListener('touchstart', this.startTouch.bind(this));
                element.addEventListener('touchend', this.endTouch.bind(this));
                element.addEventListener('touchcancel', this.endTouch.bind(this));

                this.dragStartTimer = undefined;
                this.lastMovePosition = undefined;
                this.touchesCache = [];
                this.MODIFIER = 3;
                this.dragging = false;

                this.oneFingerMove = touches.oneFingerMove;
                this.oneFingerClick = touches.oneFingerClick;
                this.oneFingerDrag = touches.oneFingerDrag;

                this.twoFingersMove = touches.twoFingersMove;
                this.twoFingersClick = touches.twoFingersClick;

                this.threeFingersClick = touches.threeFingersClick;
            }

            tryStopDrag() {
                if (this.dragStartTimer !== undefined) {
                    clearTimeout(this.dragStartTimer);
                    this.dragStartTimer = undefined;
                }
                if (this.dragging) {
                    this.dragging = false;
                    this.oneFingerDrag(false);
                }
            }

            processTouchMove(e) {
                if (e.targetTouches.length <= 2) {
                    if (e.targetTouches.length === 1 && this.dragStartTimer !== undefined) {
                        if (!(this.touchesCache[0].checkRange(new Point(e.targetTouches[0].clientX, e.targetTouches[0].clientY)))) {
                            this.tryStopDrag();
                        }
                    }

                    const pos = new Point(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
                    if (!this.lastMovePosition) {
                        this.lastMovePosition = new Point(this.touchesCache[0].x, this.touchesCache[0].y);
                    }

                    const diff = new Point(pos.x - this.lastMovePosition.x, pos.y - this.lastMovePosition.y);

                    this.lastMovePosition = pos;

                    if (Math.abs(diff.x) > 50 || Math.abs(diff.y) > 50) return;

                    if (e.targetTouches.length === 1) {
                        this.oneFingerMove(diff.x * this.MODIFIER, diff.y * this.MODIFIER);
                    }
                    if (e.targetTouches.length === 2 && Math.abs(diff.y) > 3) {
                        this.twoFingersMove(diff.x, diff.y);
                    }
                }
            }

            getTouchIndex(identifier) {
                for (let i = 0; i < this.touchesCache.length; i += 1) {
                    if (this.touchesCache[i].id === identifier) {
                        return i;
                    }
                }

                return -1;
            }

            addTouch(t) {
                if (this.getTouchIndex(t.identifier) === -1) {
                    this.touchesCache.push(new Point(t.clientX, t.clientY, t.identifier));
                }
            }

            startTouch(e) {
                for (let i = 0; i < e.changedTouches.length; i += 1) {
                    this.addTouch(e.changedTouches[i]);
                }

                if (this.touchesCache.length === 1) {
                    this.dragStartTimer = setTimeout(() => {
                        this.oneFingerDrag(true);
                        this.dragStartTimer = undefined;
                        this.dragging = true;
                    }, 1000);
                } else {
                    this.tryStopDrag();
                }
            }

            endTouch(e) {
                for (let i = 0; i < e.changedTouches.length; i += 1) {
                    const id = this.getTouchIndex(e.changedTouches[i].identifier);

                    if (id !== -1) {
                        const temp = new Point(e.changedTouches[i].clientX, e.changedTouches[i].clientY);

                        if (!(this.touchesCache[id].checkTime(temp)) || !(this.touchesCache[id].checkRange(temp))) {
                            this.touchesCache.splice(id, 1);
                        }
                    }
                }

                if (e.targetTouches.length === 0) {
                    const {
                        length
                    } = this.touchesCache;
                    if (length >= 1 && length <= 3) {
                        switch (length) {
                            case 1:
                                this.oneFingerClick();
                                break;
                            case 2:
                                this.twoFingersClick();
                                break;
                            case 3:
                                this.threeFingersClick();
                                break;
                            default:
                                break;
                        }
                    }

                    this.touchesCache = [];
                    this.lastMovePosition = undefined;
                    this.tryStopDrag();
                }
            }
        }

        //volume slider

        let SLIDERSCALE = 0;
        const HANDLECLASS = 'volume-handle';
        const COLOREDCLASS = 'volume-colored';
        const BARID = 'volume-bar';
        const NUMERICID = 'volume-numeric';
        const VOLUMEBARWRAPPER = 'volume-bar-wrapper'

        let volumeBar;
        let volumeBarColored;
        let volumeBarHandle;
        let sliderElement;

        let volumeBarNumericElement;

        let volumeNumericValue = 0;

        let numericEnabled = false;

        let drag = false;

        let correction = 0;

        const changeEvent = new Event('volumechanged');

        function setVolumeBar(value) {
            let pixelValue = value - volumeBar.offsetLeft;
            pixelValue = pixelValue <= volumeBar.offsetWidth - correction ? pixelValue : volumeBar.offsetWidth - correction;
            pixelValue = pixelValue >= correction ? pixelValue : correction;

            volumeBarColored.style.width = pixelValue;

            return toNumeric(pixelValue);
        }

        function setVolumeBarNumeric(value) {
            volumeBarNumericElement.innerText = value;
        }

        function toPixels(value) {
            return ((volumeBar.offsetWidth - correction * 2) / SLIDERSCALE) * value + correction + volumeBar.offsetLeft;
        }

        function toNumeric(value) {
            return Math.round(((value - correction) * SLIDERSCALE) / (volumeBar.offsetWidth - correction * 2));
        }

        function checkSendRequest(numericValue) {
            if (numericValue !== volumeNumericValue) {
                volumeNumericValue = numericValue;

                changeEvent.value = numericValue;
                sliderElement.dispatchEvent(changeEvent);
            }
        }

        function wheel(e) {
            updateElementAndSendRequest(toPixels(e > 0 ? volumeNumericValue + 2 : volumeNumericValue - 2));
        }

        function updateElementAndSendRequest(absolutePixels) {
            let numeric = setVolumeBar(absolutePixels);
            checkSendRequest(numeric);

            if (numericEnabled) {
                setVolumeBarNumeric(numeric);
            }
        }

        function init(initialValue) {
            volumeNumericValue = Number(initialValue);

            if (!Number.isNaN(volumeNumericValue)) {
                setVolumeBar(toPixels(volumeNumericValue));

                if (numericEnabled) {
                    setVolumeBarNumeric(volumeNumericValue);
                }
            }
        }

        function createVolumeBar(slider, scale, initValue = 0, numeric = false) {
            SLIDERSCALE = scale;
            numericEnabled = numeric;

            sliderElement = slider;

            let html = `
                    ${numericEnabled ? `<div id='${NUMERICID}'>0</div>\n` : ''}
                    <div id=${VOLUMEBARWRAPPER}>
                        <div id='${BARID}'>
                            <div class='${COLOREDCLASS}'></div>
                            <div class='${HANDLECLASS}'></div>
                        </div>
                    </div>`;

            sliderElement.innerHTML = html;

            volumeBar = sliderElement.querySelector(`#${BARID}`);

            if (numeric) {
                volumeBarNumericElement = sliderElement.querySelector(`#${NUMERICID}`);
            }

            volumeBarHandle = sliderElement.querySelector(`.${HANDLECLASS}`);
            volumeBarColored = sliderElement.querySelector(`.${COLOREDCLASS}`);

            correction = volumeBarHandle.offsetHeight / 2;
            volumeBarHandle.style.marginLeft = -correction;

            const resize_ob = new ResizeObserver(entries => {
                let height = entries[0].contentRect.height;
                volumeBarHandle.style.width = height;
                correction = height / 2;
                volumeBarHandle.style.marginLeft = -correction;
            });
            resize_ob.observe(volumeBarHandle);

            volumeBarHandle.addEventListener('touchmove', e => {
                updateElementAndSendRequest(e.targetTouches[0].clientX);
            });
            volumeBar.addEventListener('click', e => {
                updateElementAndSendRequest(e.clientX);
            });
            volumeBar.addEventListener('wheel', e => {
                wheel(e.wheelDeltaY);
            });

            volumeBarHandle.addEventListener('mousedown', () => {
                drag = true;
            });
            volumeBarHandle.addEventListener('mouseup', () => {
                drag = false;
            });
            volumeBarHandle.addEventListener('mousemove', e => {
                if (drag) updateElementAndSendRequest(e.clientX);
            });

            init(initValue);
        }

        //touch

        const CLICKINTERVAL = 200;
        const CLICKRANGE = 10;

        let touchElement;
        let touchPointers = [];

        function showPointer(p) {
            const elem = p;
            elem.style.display = 'block';
        }

        function movePointer(p, x, y) {
            const elem = p;
            elem.style.left = x - p.offsetWidth / 2;
            elem.style.top = y - p.offsetHeight / 2;
        }

        function hidePointer(p) {
            const elem = p;
            elem.style.display = 'none';
        }

        function processTouchMove(e) {
            Array.from(e.changedTouches).forEach(element => {
                movePointer(touchPointers[element.identifier], element.clientX, element.clientY);
            });
        }

        function startTouch(e) {
            Array.from(e.changedTouches).forEach(element => {
                showPointer(touchPointers[element.identifier]);
                movePointer(touchPointers[element.identifier], element.clientX, element.clientY);
            });
        }

        function endTouch(e) {
            Array.from(e.changedTouches).forEach(element => {
                hidePointer(touchPointers[element.identifier]);
            });
        }

        function createTouch(element) {
            touchElement = element;
            let pointsCount = 5;

            let pointer = new DOMParser().parseFromString('<div class="touch-pointer"></div>', 'text/html').body.firstChild;

            for (i = 0; i < pointsCount; i++) {
                touchPointers.push(pointer.cloneNode());
            }

            touchPointers.forEach(x => {
                touchElement.append(x);
            });

            touchElement.addEventListener('touchmove', processTouchMove);
            touchElement.addEventListener('touchstart', startTouch);
            touchElement.addEventListener('touchend', endTouch);
            touchElement.addEventListener('touchcancel', endTouch);
        }

        let prev = '';
        let prevBorder = '';

        function touchHide() {
            prev = touchElement.style.display;
            prevBorder = touchElement.style.border;
            touchElement.style.border = 'none';
            touchElement.style.display = 'none';
        }

        function touchShow() {
            touchElement.style.display = prev;
            setTimeout(() => {
                touchElement.style.border = prevBorder;
            }, 200);
        }

        //keys

        const buttonschangeCLICKINTERVAL = 1000;

        let keyRepeadIntervalId;
        let keyRepeatTimerId;

        const clickEvent = new Event('keyclick');

        let buttonsGlobal;

        function start(value) {
            clickEvent.value = value;

            keyRepeatTimerId = setTimeout(() => {
                keyRepeadIntervalId = setInterval(() => {
                    buttonsGlobal.dispatchEvent(clickEvent);
                }, 100);
            }, 1000);
        }

        function end() {
            clearInterval(keyRepeatTimerId);
            clearTimeout(keyRepeadIntervalId);
        }

        function toggleDisplay(buttonsArray) {
            buttonsArray.forEach(x => {
                const elem = x;
                elem.style.display = elem.style.display === 'none' ? 'block' : 'none';
            });
        }

        function createKeys(buttons) {
            buttonsGlobal = buttons;

            const buttonBack = document.createElement('button');
            buttonBack.innerHTML = '&#60;&#60;';

            const buttonPause = document.createElement('button');
            buttonPause.innerHTML = '&#10074;&#10074;';

            const buttonForth = document.createElement('button');
            buttonForth.innerHTML = '&#62;&#62;';

            const buttonMediaForth = document.createElement('button');
            buttonMediaForth.innerHTML = '&#45;&#62;';
            buttonMediaForth.style.display = 'none';

            const buttonMediaBack = document.createElement('button');
            buttonMediaBack.innerHTML = '&#60;&#45;';
            buttonMediaBack.style.display = 'none';

            const fillers = [document.createElement('span'), document.createElement('span')];
            fillers.forEach(e => {
                e.style.float = 'left';
                e.style.height = '1px';
                e.style.width = '0.5%';
            });

            buttons.append(buttonMediaBack, buttonBack, fillers[0], buttonPause, fillers[1], buttonForth, buttonMediaForth);

            buttonBack.addEventListener('touchstart', () => start('back'));
            buttonBack.addEventListener('touchend', end);
            buttonBack.addEventListener('click', () => {
                clickEvent.value = 'back';
                buttons.dispatchEvent(clickEvent);
            });
            buttonBack.addEventListener('touchcancel', end);

            buttonForth.addEventListener('touchstart', () => start('forth'));
            buttonForth.addEventListener('touchend', end);
            buttonForth.addEventListener('click', () => {
                clickEvent.value = 'forth';
                buttons.dispatchEvent(clickEvent);
            });
            buttonForth.addEventListener('touchcancel', end);

            buttonMediaBack.addEventListener('click', () => {
                clickEvent.value = 'mediaback';
                buttons.dispatchEvent(clickEvent);
            });
            buttonMediaForth.addEventListener('click', () => {
                clickEvent.value = 'mediaforth';
                buttons.dispatchEvent(clickEvent);
            });

            const buttonsArray = [buttonBack, buttonForth, buttonMediaBack, buttonMediaForth];

            let timeout;

            buttonPause.addEventListener('click', () => {
                clickEvent.value = 'pause';
                buttons.dispatchEvent(clickEvent);
            });

            buttonPause.addEventListener('touchstart', () => {
                timeout = setTimeout(() => toggleDisplay(buttonsArray), buttonschangeCLICKINTERVAL);
            });
            buttonPause.addEventListener('touchend', () => {
                clearTimeout(timeout);
            });
        }

        //text

        const textEvent = new Event('textinput');

        let textElement;

        function processText(e) {
            if (e.key === 'Enter') {
                if (e.target.value) {
                    textEvent.text = encodeURIComponent(e.target.value);
                    textElement.dispatchEvent(textEvent);
                }
                e.target.blur();
            }
        }

        function createTextInput(element) {
            textElement = element;

            element.addEventListener('keyup', processText);
        }

        //init
        function initElements(volume, devices) {
            const slider = document.getElementById('slider');
            if (slider) {
                createVolumeBar(slider, 100, volume, true);
                slider.addEventListener('volumechanged', e => sendRequest("audio", e.value));
            }

            const touch = document.getElementById('touch');
            if (touch) {
                createTouch(touch);

                new GestureDetector(touch, {
                    oneFingerClick: () => sendRequest("mouse", 'left'),
                    oneFingerMove: (x, y) => sendRequest("mousemove", `${x},${y}`),
                    oneFingerDrag: e => sendRequest("mouse", e ? 'dragstart' : 'dragstop'),
                    twoFingersClick: () => sendRequest("mouse", 'right'),
                    twoFingersMove: (x, y) => sendRequest("mouse", y > 0 ? "up" : "down"),
                    threeFingersClick: () => sendRequest("mouse", 'middle')
                });
            }

            const buttons = document.getElementById('buttons');
            if (buttons) {
                createKeys(buttons);
                buttons.addEventListener('keyclick', e => sendRequest("keyboard", e.value));
            }

            const textInput = document.getElementById('text-input');
            if (textInput) {
                createTextInput(textInput);
                textInput.addEventListener('textinput', e => sendRequest("text", e.text));
                textInput.addEventListener('focus', () => touchHide());
                textInput.addEventListener('blur', e => {
                    e.target.value = '';
                    touchShow();
                });
            }

            document.getElementById('darken').onclick = () => sendRequest('display', 'darken');

            if(devices.length > 1) {
                document.getElementById('devicon').style.display = 'block';
                document.getElementById('devicon').onclick = () => showDevices();
            }
            setDevice(devices.find(x => x.IsDefault).Id);

            document.getElementById('loader').style.display = 'none';
        }

        async function showDevices() {
            let devicesElement = document.getElementById('devices');

            if(devicesElement.style.display === 'block') {
                devicesElement.style.display = 'none';
                return;
            }

            let devices = JSON.parse(await (await sendRequest('audiodevice', 'get')).text());

            devicesElement.innerHTML = '';
            
            devices.forEach(x => {
                devicesElement.innerHTML += `
                    <div class="device" onclick='setDevice("${x.Id}")'>
                        <div>${x.IsActive ? '✅' : '&#160'}</div>
                        <div>${x.Name}</div>
                    </div>`;
            });

            devicesElement.style.display = 'block';
        }

        async function setDevice(id) {
            await sendRequest('audiodevice', id);
            let volume = await (await sendRequest('audio', 'init')).text();

            init(volume);
            document.getElementById('devices').style.display = 'none';
        }

        document.addEventListener('DOMContentLoaded', async () => {
            let pageInPortraitMode = window.innerHeight > window.innerWidth;

            window.addEventListener("resize", () => {
                if (((pageInPortraitMode === true) && (window.innerHeight < window.innerWidth)) || ((pageInPortraitMode === false) && (window.innerHeight > window.innerWidth))) {
                    pageInPortraitMode = window.innerHeight > window.innerWidth;
                    document.querySelector("meta[name=viewport]").setAttribute("content", "width=" + window.innerWidth + ", height=" + window.innerHeight + ", initial-scale=1.0, maximum-scale=1.0, user-scalable=0");
                }
            });

            document.querySelector("meta[name=viewport]").setAttribute("content", "width=" + window.innerWidth + ", height=" + window.innerHeight + ", initial-scale=1.0, maximum-scale=1.0, user-scalable=0");

            let devices = JSON.parse(await (await sendRequest('audiodevice', 'get')).text());
            let volume = await (await sendRequest('audio', 'init')).text();

            initElements(volume, devices);
        });
    </script>

    <style>
        body {
            background: #2a2a2a;
            overscroll-behavior: none;
        }
        
        #outer-container {
            display: block;
            height: 100%;
        }
        
        #inner-container-one {
            height: 100%;
            width: 100%;
        }
        
        #inner-container-two {
            display: none;
            width: 100%;
        }
        
        #volume-bar-wrapper {
            height: 25%;
        }
        
        #slider {
            height: 50%;
        }
        
        #volume-numeric {
            height: 75%;
            text-align: center;
            color: white;
            font-size: 30vh;
            user-select: none;
        }
        
        #volume-bar {
            height: 100%;
            display: flex;
            margin: 0 auto;
            width: 100%;
            background: #555;
            border-radius: 15px;
        }
        
        #volume-bar .volume-colored {
            background: #2ecc71;
            border: none;
            border-radius: 15px;
            outline: none;
        }
        
        #volume-bar .volume-handle {
            transform: scale(1.2);
            border-radius: 15px;
            background: #FFF;
            cursor: pointer;
            outline: none;
            user-select: none;
        }
        
        #buttons {
            height: 31%;
        }
        
        button {
            cursor: pointer;
            font-weight: bold;
            text-align: center;
            color: #fff;
            border-radius: 30px;
            background-color: #538fbe;
            border: 1px solid #2d6898;
            text-shadow: 0px 0px 6px rgba(0, 0, 0, .8);
            display: block;
            width: 33%;
            float: left;
            text-decoration: none;
            font-size: 18vw;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            line-height: 0px;
            height: 100%;
        }
        
        button:active {
            background-color: #73afde;
            box-shadow: 0 3px 0 #2b638f;
            transform: translateY(5px);
        }
        
        #text-input {
            height: 14%;
            width: 100%;
            background: #555;
            border-radius: 15px;
            border: 0;
            color: white;
            padding-left: 5px;
            font-size: 4vh;
            display: none;
        }
        
        #touch {
            width: 100%;
            border: 1px solid rgba(135, 206, 250, 0.541);
            border-radius: 15px;
            height: 100%;
        }
        
        .touch-pointer {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: radial-gradient(25px, lightskyblue, transparent);
            display: none;
        }
        
        #darken {
            position: absolute;
            left: 0;
            top: 0;
            width: 50px;
            height: 50px;
            font-size: 36px;
        }
        
        #devicon {
            display: none;
            position: absolute;
            left: 50px;
            top: 0;
            width: 50px;
            height: 50px;
            font-size: 36px;
        }
        
        #devices {
            position: absolute;
            left: 50px;
            top: 50px;
            width: calc(100vw - 100px);
            color: white;
            text-shadow: 0px 0px 6px rgba(0, 0, 0, .8);
            display: none;
            z-index: 1000;
        }
        
        .device {
            height: 50px;
            display: flex;
            background-color: #538fbe;
            border-radius: 15px;
            padding-left: 12px;
            border: 1px solid #2d6898;
            user-select: none;
            line-height: 50px;
            font-size: 11px;
        }
        
        #loader {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1000;
            background-color: #2a2a2a;
            top: 0;
            left: 0;
        }
        
        .margin-bottom-10 {
            margin-bottom: 10px;
        }
        
        .lds-spinner {
            display: inline-block;
            position: absolute;
            left: calc(50% - 40px);
            top: calc(50% - 40px);
            width: 80px;
            height: 80px;
        }
        
        .lds-spinner div {
            transform-origin: 40px 40px;
            animation: lds-spinner 1.2s linear infinite;
        }
        
        .lds-spinner div:after {
            content: " ";
            display: block;
            position: absolute;
            top: 3px;
            left: 37px;
            width: 6px;
            height: 18px;
            border-radius: 20%;
            background: lightskyblue;
        }
        
        .lds-spinner div:nth-child(1) {
            transform: rotate(0deg);
            animation-delay: -1.1s;
        }
        
        .lds-spinner div:nth-child(2) {
            transform: rotate(30deg);
            animation-delay: -1s;
        }
        
        .lds-spinner div:nth-child(3) {
            transform: rotate(60deg);
            animation-delay: -0.9s;
        }
        
        .lds-spinner div:nth-child(4) {
            transform: rotate(90deg);
            animation-delay: -0.8s;
        }
        
        .lds-spinner div:nth-child(5) {
            transform: rotate(120deg);
            animation-delay: -0.7s;
        }
        
        .lds-spinner div:nth-child(6) {
            transform: rotate(150deg);
            animation-delay: -0.6s;
        }
        
        .lds-spinner div:nth-child(7) {
            transform: rotate(180deg);
            animation-delay: -0.5s;
        }
        
        .lds-spinner div:nth-child(8) {
            transform: rotate(210deg);
            animation-delay: -0.4s;
        }
        
        .lds-spinner div:nth-child(9) {
            transform: rotate(240deg);
            animation-delay: -0.3s;
        }
        
        .lds-spinner div:nth-child(10) {
            transform: rotate(270deg);
            animation-delay: -0.2s;
        }
        
        .lds-spinner div:nth-child(11) {
            transform: rotate(300deg);
            animation-delay: -0.1s;
        }
        
        .lds-spinner div:nth-child(12) {
            transform: rotate(330deg);
            animation-delay: 0s;
        }
        
        @keyframes lds-spinner {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        @media only screen and (min-width: 360px) and (min-height: 361px) {
            #inner-container-one {
                height: 50%;
            }
            #inner-container-two {
                display: block;
                height: 48%;
            }
            #volume-numeric {
                font-size: 16vh;
            }
            #text-input {
                display: block;
            }
        }
        
        @media only screen and (min-width: 800px) {
            #outer-container {
                display: flex;
            }
            #inner-container-one {
                height: 99%;
            }
            #inner-container-two {
                height: 99%;
            }
            button {
                font-size: 20vh;
            }
            #volume-numeric {
                font-size: 30vh;
            }
            #text-input {
                font-size: 8vh;
            }
        }
    </style>

</head>

<body>
    <div id="devices"></div>
    <div id="darken">⬛</div>
    <div id="devicon">🎧</div>
    <div id="outer-container">
        <div id="inner-container-one" class="margin-bottom-10">
            <div id="slider" class="margin-bottom-10"></div>
            <div id="buttons" class="margin-bottom-10"></div>
            <input type="text" class="margin-bottom-10" autocomplete="false" id="text-input" />
        </div>
        <div id="inner-container-two">
            <div id="touch"></div>
        </div>
    </div>
    <div id="loader">
        <div class="lds-spinner">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</body>

</html>